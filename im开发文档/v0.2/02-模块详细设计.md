# IM 服务 - 模块详细设计（v0.2）

## 一、项目结构

```
im-service/
├── app/
│   ├── __init__.py
│   ├── main.py                    # FastAPI 应用入口
│   ├── config.py                  # 配置管理（基于脚手架）
│   ├── dependencies.py            # 依赖注入（基于脚手架）
│   │
│   ├── api/                       # API 路由
│   │   ├── __init__.py
│   │   ├── message.py            # 消息 API（IM核心）
│   │   ├── group.py              # 群组 API（IM核心）
│   │   ├── user.py               # 用户 API（IM核心）
│   │   └── ai.py                 # AI交互 API（AI封装层，可选）
│   │
│   ├── websocket/                 # WebSocket 处理（基于脚手架）
│   │   ├── __init__.py
│   │   ├── manager.py            # 连接管理器（脚手架提供）
│   │   └── handler.py           # 消息处理器（业务逻辑）
│   │
│   ├── services/                  # 业务服务层
│   │   ├── __init__.py
│   │   ├── core/                 # IM核心服务
│   │   │   ├── __init__.py
│   │   │   ├── message_service.py    # 消息服务
│   │   │   ├── group_service.py      # 群组服务
│   │   │   ├── user_service.py       # 用户服务
│   │   │   └── websocket_service.py  # WebSocket 服务
│   │   └── ai/                    # AI封装层服务
│   │       ├── __init__.py
│   │       ├── ai_interaction_service.py  # AI交互服务
│   │       └── message_router_service.py  # 消息路由服务
│   │
│   ├── models/                    # 数据模型
│   │   ├── __init__.py
│   │   ├── user.py               # 用户模型
│   │   ├── group.py              # 群组模型
│   │   ├── group_member.py       # 群组成员模型
│   │   ├── message.py            # 消息模型
│   │   └── ai_interaction_record.py  # AI交互记录模型
│   │
│   ├── schemas/                   # Pydantic 模型
│   │   ├── __init__.py
│   │   ├── user.py               # 用户 Schema
│   │   ├── group.py              # 群组 Schema
│   │   ├── message.py            # 消息 Schema
│   │   └── ai.py                 # AI Schema
│   │
│   ├── repositories/              # 数据访问层
│   │   ├── __init__.py
│   │   ├── user_repository.py    # 用户仓储
│   │   ├── group_repository.py   # 群组仓储
│   │   ├── group_member_repository.py  # 群组成员仓储
│   │   ├── message_repository.py # 消息仓储
│   │   └── ai_interaction_repository.py  # AI交互记录仓储
│   │
│   ├── tasks/                     # Celery 任务（可选，基于脚手架）
│   │   ├── __init__.py
│   │   ├── celery_app.py         # Celery 应用配置（脚手架提供）
│   │   └── ai_interaction_task.py  # AI交互任务（AI封装层）
│   │
│   ├── db/                        # 数据库相关（基于脚手架）
│   │   ├── __init__.py
│   │   ├── database.py           # 数据库连接（脚手架提供）
│   │   ├── base.py               # 基础模型（脚手架提供）
│   │   └── session.py             # 会话管理（脚手架提供）
│   │
│   └── utils/                     # 工具类（基于脚手架）
│       ├── __init__.py
│       ├── logger.py             # 日志工具（脚手架提供）
│       └── id_generator.py       # ID 生成器（脚手架提供）
│
├── alembic/                       # 数据库迁移（基于脚手架）
│   ├── versions/
│   └── env.py
│
├── tests/                         # 测试
│   ├── __init__.py
│   ├── test_message.py
│   ├── test_group.py
│   ├── test_user.py
│   ├── test_ai_interaction.py
│   └── locustfile.py             # 压测脚本
│
├── requirements.txt               # Python 依赖
├── .env.example                   # 环境变量示例
├── alembic.ini                    # Alembic 配置（脚手架提供）
└── README.md                      # 项目说明
```

---

## 二、IM核心模块详细设计

### 2.1 用户模型 (app/models/user.py)

#### 功能说明
- 用户信息管理
- 用户身份标签（PATIENT/DOCTOR/AI_ASSISTANT）

#### 设计要点

```python
from sqlalchemy import Column, String, Index
from app.db.base import BaseModel

class User(BaseModel):
    """用户模型"""
    __tablename__ = "users"
    
    user_id = Column(String(48), unique=True, nullable=False, index=True, comment='用户唯一标识')
    username = Column(String(64), nullable=False, comment='用户名')
    user_role = Column(
        String(32), 
        nullable=False, 
        default='PATIENT',
        comment='用户身份：PATIENT(患者)/DOCTOR(医生)/AI_ASSISTANT(医生AI助手)'
    )
    
    __table_args__ = (
        Index('idx_user_id', 'user_id'),
        Index('idx_user_role', 'user_role'),
    )
    
    def is_patient(self) -> bool:
        """判断是否为患者"""
        return self.user_role == 'PATIENT'
    
    def is_doctor(self) -> bool:
        """判断是否为医生"""
        return self.user_role == 'DOCTOR'
    
    def is_ai_assistant(self) -> bool:
        """判断是否为AI助手"""
        return self.user_role == 'AI_ASSISTANT'
```

#### 字段说明

| 字段名 | 类型 | 必填 | 说明 | 约束 |
|--------|------|------|------|------|
| user_id | String(48) | 是 | 用户唯一标识 | 唯一索引 |
| username | String(64) | 是 | 用户名 | 非空 |
| user_role | String(32) | 是 | 用户身份 | 默认'PATIENT'，可选值：'PATIENT'/'DOCTOR'/'AI_ASSISTANT' |

---

### 2.2 群组模型 (app/models/group.py)

#### 功能说明
- 群组信息管理
- 群组创建和管理

#### 设计要点

```python
from sqlalchemy import Column, String, Text, Index
from app.db.base import BaseModel

class Group(BaseModel):
    """群组模型"""
    __tablename__ = "groups"
    
    group_id = Column(String(64), unique=True, nullable=False, index=True, comment='群组唯一标识')
    group_name = Column(String(128), nullable=False, comment='群组名称')
    description = Column(Text, nullable=True, comment='群组描述')
    created_by = Column(String(48), nullable=False, index=True, comment='创建人ID')
    
    __table_args__ = (
        Index('idx_group_id', 'group_id'),
        Index('idx_created_by', 'created_by'),
    )
```

#### 字段说明

| 字段名 | 类型 | 必填 | 说明 | 约束 |
|--------|------|------|------|------|
| group_id | String(64) | 是 | 群组唯一标识 | 唯一索引 |
| group_name | String(128) | 是 | 群组名称 | 非空 |
| description | Text | 否 | 群组描述 | 可为空 |
| created_by | String(48) | 是 | 创建人ID | 索引 |

---

### 2.3 群组成员模型 (app/models/group_member.py)

#### 功能说明
- 群组成员管理
- 用户在群组中的身份标签

#### 设计要点

```python
from sqlalchemy import Column, String, DateTime, Index, UniqueConstraint
from sqlalchemy.sql import func
from app.db.base import BaseModel

class GroupMember(BaseModel):
    """群组成员模型"""
    __tablename__ = "group_members"
    
    group_id = Column(String(64), nullable=False, index=True, comment='群组ID')
    user_id = Column(String(48), nullable=False, index=True, comment='用户ID')
    user_role = Column(
        String(32), 
        nullable=False, 
        comment='用户在群组中的身份标签：PATIENT/DOCTOR/AI_ASSISTANT'
    )
    joined_at = Column(DateTime, server_default=func.now(), nullable=False, comment='加入时间')
    
    __table_args__ = (
        UniqueConstraint('group_id', 'user_id', name='uk_group_user'),
        Index('idx_group_id', 'group_id'),
        Index('idx_user_id', 'user_id'),
        Index('idx_user_role', 'user_role'),
    )
```

#### 字段说明

| 字段名 | 类型 | 必填 | 说明 | 约束 |
|--------|------|------|------|------|
| group_id | String(64) | 是 | 群组ID | 与user_id联合唯一 |
| user_id | String(48) | 是 | 用户ID | 与group_id联合唯一 |
| user_role | String(32) | 是 | 用户在群组中的身份标签 | 可选值：'PATIENT'/'DOCTOR'/'AI_ASSISTANT' |
| joined_at | DateTime | 是 | 加入时间 | 自动设置 |

**重要说明**：
- `user_role` 字段表示**用户在群组中的身份**，可能与用户在系统中的全局身份（`User.user_role`）不同
- 例如：一个医生用户可以在某个群组中被标记为"患者"身份

---

### 2.4 消息模型 (app/models/message.py)

#### 功能说明
- 消息存储
- 支持群组消息

#### 设计要点

```python
from sqlalchemy import Column, String, Text, Index
from app.db.base import BaseModel

class Message(BaseModel):
    """消息模型"""
    __tablename__ = "messages"
    
    message_id = Column(String(64), unique=True, nullable=False, index=True, comment='消息唯一标识')
    group_id = Column(String(64), nullable=False, index=True, comment='群组ID')
    from_user_id = Column(String(48), nullable=False, index=True, comment='发送人ID')
    msg_type = Column(
        String(32), 
        nullable=False, 
        default='TEXT',
        comment='消息类型：TEXT(文本)/IMAGE(图片)/AI_REPLY(AI回复)'
    )
    msg_content = Column(Text, nullable=False, comment='消息内容')
    
    __table_args__ = (
        Index('idx_group_id', 'group_id'),
        Index('idx_from_user_id', 'from_user_id'),
        Index('idx_created_at', 'created_at'),
        Index('idx_group_created', 'group_id', 'created_at'),
    )
```

#### 字段说明

| 字段名 | 类型 | 必填 | 说明 | 约束 |
|--------|------|------|------|------|
| message_id | String(64) | 是 | 消息唯一标识 | 唯一索引 |
| group_id | String(64) | 是 | 群组ID | 索引 |
| from_user_id | String(48) | 是 | 发送人ID | 索引 |
| msg_type | String(32) | 是 | 消息类型 | 默认'TEXT'，可选值：'TEXT'/'IMAGE'/'AI_REPLY' |
| msg_content | Text | 是 | 消息内容 | 非空 |

**重要说明**：
- 所有消息都关联到群组（`group_id`），不支持单聊消息
- `from_user_id` 可以是普通用户ID，也可以是系统AI助手ID（如 'ai_assistant_001'）

---

### 2.5 AI交互记录模型 (app/models/ai_interaction_record.py)

#### 功能说明
- AI交互记录管理
- 记录AI服务调用情况

#### 设计要点

```python
from sqlalchemy import Column, String, Text, Integer, BigInteger, Index
from app.db.base import BaseModel

class AIInteractionRecord(BaseModel):
    """AI交互记录模型"""
    __tablename__ = "ai_interaction_records"
    
    record_id = Column(String(64), unique=True, nullable=False, index=True, comment='记录唯一标识')
    group_id = Column(String(64), nullable=False, index=True, comment='群组ID')
    user_message_id = Column(String(64), nullable=False, index=True, comment='用户消息ID')
    ai_message_id = Column(String(64), nullable=True, index=True, comment='AI回复消息ID')
    ai_service_url = Column(String(256), nullable=True, comment='AI服务URL')
    request_content = Column(Text, nullable=True, comment='请求内容（JSON格式）')
    response_content = Column(Text, nullable=True, comment='响应内容（JSON格式）')
    status = Column(
        Integer, 
        nullable=False, 
        default=0,
        comment='状态：0-处理中，1-成功，2-失败'
    )
    duration_ms = Column(BigInteger, nullable=True, comment='处理耗时（毫秒）')
    error_message = Column(String(500), nullable=True, comment='错误信息')
    
    __table_args__ = (
        Index('idx_group_id', 'group_id'),
        Index('idx_user_message_id', 'user_message_id'),
        Index('idx_status', 'status'),
        Index('idx_created_at', 'created_at'),
    )
```

#### 字段说明

| 字段名 | 类型 | 必填 | 说明 | 约束 |
|--------|------|------|------|------|
| record_id | String(64) | 是 | 记录唯一标识 | 唯一索引 |
| group_id | String(64) | 是 | 群组ID | 索引 |
| user_message_id | String(64) | 是 | 用户消息ID | 索引 |
| ai_message_id | String(64) | 否 | AI回复消息ID | 可为空 |
| ai_service_url | String(256) | 否 | AI服务URL | 可为空 |
| request_content | Text | 否 | 请求内容（JSON格式） | 可为空 |
| response_content | Text | 否 | 响应内容（JSON格式） | 可为空 |
| status | Integer | 是 | 状态 | 默认0，可选值：0(处理中)/1(成功)/2(失败) |
| duration_ms | BigInteger | 否 | 处理耗时（毫秒） | 可为空 |
| error_message | String(500) | 否 | 错误信息 | 可为空 |

---

### 2.6 用户服务 (app/services/core/user_service.py)

#### 功能说明
- 用户信息管理
- 用户身份标签管理

#### 设计要点

```python
from sqlalchemy.orm import Session
from typing import Optional
from app.repositories.user_repository import UserRepository
from app.schemas.user import UserCreate, UserUpdate, UserResponse
from app.utils.id_generator import generate_user_id

class UserService:
    """用户服务（IM核心）"""
    
    def __init__(self, db: Session):
        self.user_repo = UserRepository(db)
    
    def create_user(self, user_create: UserCreate) -> UserResponse:
        """
        创建用户
        
        参数：
            user_create: 用户创建信息，包含username和user_role
        
        返回：
            UserResponse: 创建的用户信息
        
        异常：
            ValueError: 如果user_role不是有效值
        """
        # 验证user_role
        valid_roles = ['PATIENT', 'DOCTOR', 'AI_ASSISTANT']
        if user_create.user_role not in valid_roles:
            raise ValueError(f"Invalid user_role: {user_create.user_role}. Must be one of {valid_roles}")
        
        # 生成user_id
        user_id = generate_user_id()
        
        # 创建用户
        user = self.user_repo.create(
            user_id=user_id,
            username=user_create.username,
            user_role=user_create.user_role
        )
        
        return UserResponse.from_orm(user)
    
    def get_user(self, user_id: str) -> Optional[UserResponse]:
        """
        获取用户信息
        
        参数：
            user_id: 用户ID
        
        返回：
            UserResponse: 用户信息，如果不存在则返回None
        """
        user = self.user_repo.get_by_id(user_id)
        if not user:
            return None
        return UserResponse.from_orm(user)
    
    def update_user_role(self, user_id: str, new_role: str) -> UserResponse:
        """
        更新用户身份标签
        
        参数：
            user_id: 用户ID
            new_role: 新的身份标签，必须是'PATIENT'/'DOCTOR'/'AI_ASSISTANT'之一
        
        返回：
            UserResponse: 更新后的用户信息
        
        异常：
            ValueError: 如果用户不存在或new_role不是有效值
        """
        # 验证new_role
        valid_roles = ['PATIENT', 'DOCTOR', 'AI_ASSISTANT']
        if new_role not in valid_roles:
            raise ValueError(f"Invalid user_role: {new_role}. Must be one of {valid_roles}")
        
        user = self.user_repo.get_by_id(user_id)
        if not user:
            raise ValueError(f"User not found: {user_id}")
        
        # 更新身份标签
        user.user_role = new_role
        updated_user = self.user_repo.update(user)
        
        return UserResponse.from_orm(updated_user)
```

---

### 2.7 群组服务 (app/services/core/group_service.py)

#### 功能说明
- 群组创建和管理
- 群组成员管理

#### 设计要点

```python
from sqlalchemy.orm import Session
from typing import List, Optional
from app.repositories.group_repository import GroupRepository
from app.repositories.group_member_repository import GroupMemberRepository
from app.schemas.group import GroupCreate, GroupResponse, GroupMemberAdd
from app.utils.id_generator import generate_group_id

class GroupService:
    """群组服务（IM核心）"""
    
    def __init__(self, db: Session):
        self.group_repo = GroupRepository(db)
        self.member_repo = GroupMemberRepository(db)
    
    def create_group(self, group_create: GroupCreate, creator_id: str) -> GroupResponse:
        """
        创建群组
        
        参数：
            group_create: 群组创建信息，包含group_name和description
            creator_id: 创建人ID
        
        返回：
            GroupResponse: 创建的群组信息
        
        异常：
            ValueError: 如果创建人不存在
        """
        # 生成group_id
        group_id = generate_group_id()
        
        # 创建群组
        group = self.group_repo.create(
            group_id=group_id,
            group_name=group_create.group_name,
            description=group_create.description,
            created_by=creator_id
        )
        
        # 将创建人添加为群组成员（身份为DOCTOR）
        self.member_repo.add_member(
            group_id=group_id,
            user_id=creator_id,
            user_role='DOCTOR'  # 创建人默认为医生身份
        )
        
        return GroupResponse.from_orm(group)
    
    def add_member(self, group_id: str, member_add: GroupMemberAdd) -> bool:
        """
        添加群组成员
        
        参数：
            group_id: 群组ID
            member_add: 成员添加信息，包含user_id和user_role
        
        返回：
            bool: 是否添加成功
        
        异常：
            ValueError: 如果群组不存在或用户已在群组中
        """
        # 检查群组是否存在
        group = self.group_repo.get_by_id(group_id)
        if not group:
            raise ValueError(f"Group not found: {group_id}")
        
        # 检查用户是否已在群组中
        existing_member = self.member_repo.get_member(group_id, member_add.user_id)
        if existing_member:
            raise ValueError(f"User {member_add.user_id} already in group {group_id}")
        
        # 添加成员
        self.member_repo.add_member(
            group_id=group_id,
            user_id=member_add.user_id,
            user_role=member_add.user_role
        )
        
        return True
    
    def get_group_members(self, group_id: str) -> List[dict]:
        """
        获取群组成员列表
        
        参数：
            group_id: 群组ID
        
        返回：
            List[dict]: 成员列表，每个成员包含user_id和user_role
        
        异常：
            ValueError: 如果群组不存在
        """
        group = self.group_repo.get_by_id(group_id)
        if not group:
            raise ValueError(f"Group not found: {group_id}")
        
        members = self.member_repo.get_members_by_group(group_id)
        return [
            {
                'user_id': member.user_id,
                'user_role': member.user_role,
                'joined_at': member.joined_at.isoformat()
            }
            for member in members
        ]
```

---

### 2.8 消息服务 (app/services/core/message_service.py)

#### 功能说明
- 消息接收和处理
- 消息存储和查询
- **不依赖AI服务**

#### 设计要点

```python
from sqlalchemy.orm import Session
from typing import List, Optional, Tuple
from app.repositories.message_repository import MessageRepository
from app.repositories.group_repository import GroupRepository
from app.schemas.message import MessageCreate, MessageResponse
from app.utils.id_generator import generate_message_id

class MessageService:
    """消息服务（IM核心）"""
    
    def __init__(self, db: Session):
        self.message_repo = MessageRepository(db)
        self.group_repo = GroupRepository(db)
    
    def send_message(
        self, 
        message_create: MessageCreate, 
        from_user_id: str
    ) -> MessageResponse:
        """
        发送消息
        
        参数：
            message_create: 消息创建信息，包含group_id和content
            from_user_id: 发送人ID
        
        返回：
            MessageResponse: 创建的消息信息
        
        异常：
            ValueError: 如果群组不存在或发送人不在群组中
        """
        # 检查群组是否存在
        group = self.group_repo.get_by_id(message_create.group_id)
        if not group:
            raise ValueError(f"Group not found: {message_create.group_id}")
        
        # 生成message_id
        message_id = generate_message_id()
        
        # 创建消息
        message = self.message_repo.create(
            message_id=message_id,
            group_id=message_create.group_id,
            from_user_id=from_user_id,
            msg_type='TEXT',
            msg_content=message_create.content
        )
        
        return MessageResponse.from_orm(message)
    
    def get_messages(
        self, 
        group_id: str, 
        page: int = 1, 
        page_size: int = 20
    ) -> Tuple[List[MessageResponse], int]:
        """
        获取群组消息列表
        
        参数：
            group_id: 群组ID
            page: 页码，从1开始
            page_size: 每页数量，最大100
        
        返回：
            Tuple[List[MessageResponse], int]: (消息列表, 总数量)
        
        异常：
            ValueError: 如果群组不存在或分页参数无效
        """
        # 验证分页参数
        if page < 1:
            raise ValueError("Page must be >= 1")
        if page_size < 1 or page_size > 100:
            raise ValueError("Page size must be between 1 and 100")
        
        # 检查群组是否存在
        group = self.group_repo.get_by_id(group_id)
        if not group:
            raise ValueError(f"Group not found: {group_id}")
        
        # 获取消息列表
        messages, total = self.message_repo.get_by_group(
            group_id=group_id,
            page=page,
            page_size=page_size
        )
        
        return [MessageResponse.from_orm(m) for m in messages], total
```

**重要说明**：
- 消息服务**不依赖AI服务**，只负责消息的存储和查询
- AI相关的逻辑由AI封装层处理

---

### 2.9 WebSocket服务 (app/services/core/websocket_service.py)

#### 功能说明
- WebSocket连接管理
- 实时消息推送
- **不依赖AI服务**

#### 设计要点

```python
from app.websocket.manager import ConnectionManager
from typing import Optional, List

class WebSocketService:
    """WebSocket服务（IM核心）"""
    
    def __init__(self):
        self.manager = ConnectionManager()  # 使用脚手架提供的管理器
    
    async def send_message_to_group(
        self, 
        group_id: str, 
        message: dict,
        exclude_user_id: Optional[str] = None
    ) -> int:
        """
        发送消息给群组所有成员
        
        参数：
            group_id: 群组ID
            message: 消息内容（字典格式）
            exclude_user_id: 排除的用户ID（可选，用于排除发送人）
        
        返回：
            int: 成功推送的用户数量
        
        说明：
            - 消息格式：{"type": "message", "data": {...}}
            - 会自动排除断开的连接
        """
        # 获取群组所有成员的user_id（需要从数据库查询）
        # 这里简化处理，实际应该从GroupMemberRepository获取
        # member_ids = self.member_repo.get_member_ids_by_group(group_id)
        
        # 广播消息给所有连接的成员
        sent_count = await self.manager.broadcast_to_group(
            group_id=group_id,
            message=message,
            exclude_user_id=exclude_user_id
        )
        
        return sent_count
    
    async def send_message_to_user(
        self, 
        user_id: str, 
        message: dict
    ) -> bool:
        """
        发送消息给指定用户
        
        参数：
            user_id: 用户ID
            message: 消息内容（字典格式）
        
        返回：
            bool: 是否发送成功
        """
        return await self.manager.send_personal_message(
            message=message,
            user_id=user_id
        )
```

---

## 三、AI封装层模块详细设计

### 3.1 消息路由服务 (app/services/ai/message_router_service.py)

#### 功能说明
- 用户身份识别
- 消息路由规则判断
- 决定是否转发给AI服务

#### 设计要点

```python
from sqlalchemy.orm import Session
from app.services.core.user_service import UserService
from app.repositories.group_member_repository import GroupMemberRepository
from typing import Optional

class MessageRouterService:
    """消息路由服务（AI封装层）"""
    
    # 需要转发给AI的用户身份列表
    AI_ROUTING_ROLES = ['PATIENT']  # 只有患者消息需要转发给AI
    
    def __init__(self, db: Session):
        self.user_service = UserService(db)
        self.member_repo = GroupMemberRepository(db)
    
    def should_route_to_ai(
        self, 
        group_id: str, 
        user_id: str
    ) -> bool:
        """
        判断消息是否需要转发给AI服务
        
        参数：
            group_id: 群组ID
            user_id: 发送人ID
        
        返回：
            bool: True表示需要转发给AI，False表示不需要
        
        逻辑：
            1. 获取用户在群组中的身份标签（group_members.user_role）
            2. 如果身份是PATIENT，则返回True
            3. 如果身份是DOCTOR或AI_ASSISTANT，则返回False
        
        异常：
            ValueError: 如果用户不在群组中
        """
        # 获取用户在群组中的身份
        member = self.member_repo.get_member(group_id, user_id)
        if not member:
            raise ValueError(f"User {user_id} not in group {group_id}")
        
        # 判断是否需要转发给AI
        # 只有患者（PATIENT）的消息需要转发给AI
        return member.user_role in self.AI_ROUTING_ROLES
    
    def get_user_role_in_group(
        self, 
        group_id: str, 
        user_id: str
    ) -> Optional[str]:
        """
        获取用户在群组中的身份标签
        
        参数：
            group_id: 群组ID
            user_id: 用户ID
        
        返回：
            Optional[str]: 用户身份标签，如果不在群组中则返回None
        """
        member = self.member_repo.get_member(group_id, user_id)
        if not member:
            return None
        return member.user_role
```

**重要说明**：
- 路由规则基于**用户在群组中的身份标签**（`group_members.user_role`），而不是用户在系统中的全局身份
- 当前规则：只有`PATIENT`身份的消息需要转发给AI
- 可以通过修改`AI_ROUTING_ROLES`来调整路由规则

---

### 3.2 AI交互服务 (app/services/ai/ai_interaction_service.py)

#### 功能说明
- 与外部AI服务通信（HTTP API）
- AI回复消息处理
- AI交互记录管理

#### 设计要点

```python
from sqlalchemy.orm import Session
from typing import Optional, Dict, Any
import httpx
import json
import time
from app.repositories.ai_interaction_repository import AIInteractionRepository
from app.repositories.message_repository import MessageRepository
from app.services.core.message_service import MessageService
from app.services.core.websocket_service import WebSocketService
from app.utils.id_generator import generate_record_id, generate_message_id
from app.config import settings

class AIInteractionService:
    """AI交互服务（AI封装层）"""
    
    def __init__(self, db: Session):
        self.db = db
        self.ai_repo = AIInteractionRepository(db)
        self.message_repo = MessageRepository(db)
        self.message_service = MessageService(db)
        self.websocket_service = WebSocketService()
    
    async def process_ai_request(
        self,
        group_id: str,
        user_message_id: str,
        user_message_content: str,
        conversation_history: Optional[List[Dict[str, str]]] = None
    ) -> Optional[str]:
        """
        处理AI请求，调用外部AI服务并创建AI回复消息
        
        参数：
            group_id: 群组ID
            user_message_id: 用户消息ID
            user_message_content: 用户消息内容
            conversation_history: 对话历史（可选），格式：[{"role": "user", "content": "..."}, ...]
        
        返回：
            Optional[str]: AI回复消息ID，如果失败则返回None
        
        异常：
            Exception: AI服务调用失败时抛出异常
        
        流程：
            1. 创建AI交互记录（状态：处理中）
            2. 调用外部AI服务（HTTP API）
            3. 接收AI回复
            4. 创建AI助手消息
            5. 更新AI交互记录（状态：成功/失败）
            6. 通过WebSocket推送AI回复给群组
        """
        # 1. 创建AI交互记录
        record_id = generate_record_id()
        request_content = json.dumps({
            "user_message": user_message_content,
            "conversation_history": conversation_history or []
        })
        
        record = self.ai_repo.create(
            record_id=record_id,
            group_id=group_id,
            user_message_id=user_message_id,
            ai_service_url=settings.ai_service_url,
            request_content=request_content,
            status=0  # 处理中
        )
        
        start_time = time.time()
        
        try:
            # 2. 调用外部AI服务
            ai_response = await self._call_ai_service(
                user_message_content,
                conversation_history
            )
            
            duration_ms = int((time.time() - start_time) * 1000)
            
            # 3. 创建AI助手消息
            ai_message_id = generate_message_id()
            ai_message = self.message_repo.create(
                message_id=ai_message_id,
                group_id=group_id,
                from_user_id='ai_assistant_001',  # 系统AI助手ID
                msg_type='AI_REPLY',
                msg_content=ai_response
            )
            
            # 4. 更新AI交互记录
            self.ai_repo.update_success(
                record_id=record_id,
                ai_message_id=ai_message_id,
                response_content=json.dumps({"response": ai_response}),
                duration_ms=duration_ms
            )
            
            # 5. 通过WebSocket推送AI回复
            await self.websocket_service.send_message_to_group(
                group_id=group_id,
                message={
                    "type": "ai_reply",
                    "message_id": ai_message_id,
                    "content": ai_response,
                    "user_message_id": user_message_id
                }
            )
            
            return ai_message_id
            
        except Exception as e:
            # 更新为失败状态
            duration_ms = int((time.time() - start_time) * 1000)
            self.ai_repo.update_failed(
                record_id=record_id,
                error_message=str(e)
            )
            raise
    
    async def _call_ai_service(
        self,
        user_message: str,
        conversation_history: Optional[List[Dict[str, str]]] = None
    ) -> str:
        """
        调用外部AI服务（HTTP API）
        
        参数：
            user_message: 用户消息内容
            conversation_history: 对话历史（可选）
        
        返回：
            str: AI回复内容
        
        异常：
            httpx.HTTPError: HTTP请求失败
            ValueError: AI服务返回格式错误
        
        AI服务API规范：
            - URL: 从配置读取（settings.ai_service_url）
            - Method: POST
            - Headers: {"Content-Type": "application/json", "Authorization": "Bearer {api_key}"}
            - Request Body: {
                "message": "用户消息",
                "history": [{"role": "user", "content": "..."}, ...]
              }
            - Response: {
                "reply": "AI回复内容"
              }
        """
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                url=settings.ai_service_url,
                headers={
                    "Content-Type": "application/json",
                    "Authorization": f"Bearer {settings.ai_service_api_key}"
                },
                json={
                    "message": user_message,
                    "history": conversation_history or []
                }
            )
            response.raise_for_status()
            
            result = response.json()
            if "reply" not in result:
                raise ValueError("Invalid AI service response format: missing 'reply' field")
            
            return result["reply"]
```

**重要说明**：
- AI服务通过**HTTP API**通信，不直接依赖LangChain等AI框架
- AI服务URL和API密钥从配置读取（`settings.ai_service_url`、`settings.ai_service_api_key`）
- AI服务返回格式必须包含`reply`字段
- 如果AI服务不可用，会记录错误但不影响IM核心功能

---

## 四、Schema设计

### 4.1 用户Schema (app/schemas/user.py)

```python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Literal

class UserCreate(BaseModel):
    """用户创建Schema"""
    username: str = Field(..., min_length=1, max_length=64, description='用户名')
    user_role: Literal['PATIENT', 'DOCTOR', 'AI_ASSISTANT'] = Field(
        default='PATIENT',
        description='用户身份：PATIENT(患者)/DOCTOR(医生)/AI_ASSISTANT(医生AI助手)'
    )

class UserUpdate(BaseModel):
    """用户更新Schema"""
    username: Optional[str] = Field(None, min_length=1, max_length=64, description='用户名')
    user_role: Optional[Literal['PATIENT', 'DOCTOR', 'AI_ASSISTANT']] = Field(
        None,
        description='用户身份'
    )

class UserResponse(BaseModel):
    """用户响应Schema"""
    id: int
    user_id: str
    username: str
    user_role: str
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True
```

### 4.2 群组Schema (app/schemas/group.py)

```python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional, List

class GroupCreate(BaseModel):
    """群组创建Schema"""
    group_name: str = Field(..., min_length=1, max_length=128, description='群组名称')
    description: Optional[str] = Field(None, description='群组描述')

class GroupResponse(BaseModel):
    """群组响应Schema"""
    id: int
    group_id: str
    group_name: str
    description: Optional[str]
    created_by: str
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class GroupMemberAdd(BaseModel):
    """群组成员添加Schema"""
    user_id: str = Field(..., min_length=1, max_length=48, description='用户ID')
    user_role: Literal['PATIENT', 'DOCTOR', 'AI_ASSISTANT'] = Field(
        ...,
        description='用户在群组中的身份标签'
    )
```

### 4.3 消息Schema (app/schemas/message.py)

```python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import List

class MessageCreate(BaseModel):
    """消息创建Schema"""
    group_id: str = Field(..., min_length=1, max_length=64, description='群组ID')
    content: str = Field(..., min_length=1, max_length=5000, description='消息内容')

class MessageResponse(BaseModel):
    """消息响应Schema"""
    id: int
    message_id: str
    group_id: str
    from_user_id: str
    msg_type: str
    msg_content: str
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True

class MessageListResponse(BaseModel):
    """消息列表响应Schema"""
    messages: List[MessageResponse]
    total: int
    page: int
    page_size: int
```

---

## 五、Repository设计

### 5.1 用户仓储 (app/repositories/user_repository.py)

```python
from sqlalchemy.orm import Session
from typing import Optional
from app.models.user import User

class UserRepository:
    """用户仓储"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def create(self, user_id: str, username: str, user_role: str) -> User:
        """创建用户"""
        user = User(
            user_id=user_id,
            username=username,
            user_role=user_role
        )
        self.db.add(user)
        self.db.commit()
        self.db.refresh(user)
        return user
    
    def get_by_id(self, user_id: str) -> Optional[User]:
        """根据user_id获取用户"""
        return self.db.query(User).filter(User.user_id == user_id).first()
    
    def update(self, user: User) -> User:
        """更新用户"""
        self.db.commit()
        self.db.refresh(user)
        return user
```

### 5.2 消息仓储 (app/repositories/message_repository.py)

```python
from sqlalchemy.orm import Session
from sqlalchemy import desc
from typing import List, Tuple
from app.models.message import Message

class MessageRepository:
    """消息仓储"""
    
    def __init__(self, db: Session):
        self.db = db
    
    def create(
        self,
        message_id: str,
        group_id: str,
        from_user_id: str,
        msg_type: str,
        msg_content: str
    ) -> Message:
        """创建消息"""
        message = Message(
            message_id=message_id,
            group_id=group_id,
            from_user_id=from_user_id,
            msg_type=msg_type,
            msg_content=msg_content
        )
        self.db.add(message)
        self.db.commit()
        self.db.refresh(message)
        return message
    
    def get_by_group(
        self,
        group_id: str,
        page: int = 1,
        page_size: int = 20
    ) -> Tuple[List[Message], int]:
        """根据群组ID获取消息列表（分页）"""
        query = self.db.query(Message).filter(Message.group_id == group_id)
        total = query.count()
        messages = query.order_by(desc(Message.created_at)).offset(
            (page - 1) * page_size
        ).limit(page_size).all()
        return messages, total
```

---

## 六、配置管理

### 6.1 AI服务配置 (app/config.py扩展)

```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # ... 其他配置（脚手架提供） ...
    
    # AI服务配置（AI封装层使用）
    ai_service_url: str = Field(..., description='外部AI服务URL')
    ai_service_api_key: str = Field(..., description='外部AI服务API密钥')
    ai_service_timeout: int = Field(default=30, description='AI服务请求超时时间（秒）')
    
    class Config:
        env_file = ".env"
        case_sensitive = False

settings = Settings()
```

---

**文档版本**：v0.2  
**创建时间**：2025-01-27  
**更新说明**：重新设计，实现IM核心与AI服务的完全解耦
