# 轻量级 IM 服务 - 模块详细设计

## 一、项目结构

```
im-service/
├── app/
│   ├── __init__.py
│   ├── main.py                    # FastAPI 应用入口
│   ├── config.py                  # 配置管理
│   ├── dependencies.py            # 依赖注入
│   │
│   ├── api/                       # API 路由
│   │   ├── __init__.py
│   │   ├── message.py            # 消息 API
│   │   └── ai.py                 # AI 相关 API
│   │
│   ├── websocket/                 # WebSocket 处理
│   │   ├── __init__.py
│   │   ├── manager.py            # 连接管理器
│   │   └── handler.py            # 消息处理器
│   │
│   ├── services/                   # 业务服务层
│   │   ├── __init__.py
│   │   ├── message_service.py    # 消息服务
│   │   ├── ai_service.py         # AI 服务
│   │   └── websocket_service.py  # WebSocket 服务
│   │
│   ├── models/                     # 数据模型
│   │   ├── __init__.py
│   │   ├── message.py            # 消息模型
│   │   └── ai_chat_record.py     # AI 聊天记录模型
│   │
│   ├── schemas/                    # Pydantic 模型
│   │   ├── __init__.py
│   │   ├── message.py            # 消息 Schema
│   │   └── ai.py                 # AI Schema
│   │
│   ├── repositories/               # 数据访问层
│   │   ├── __init__.py
│   │   ├── message_repository.py  # 消息仓储
│   │   └── ai_chat_repository.py  # AI 聊天记录仓储
│   │
│   ├── tasks/                      # Celery 任务
│   │   ├── __init__.py
│   │   ├── celery_app.py         # Celery 应用配置
│   │   └── ai_reply_task.py     # AI 回复任务
│   │
│   ├── db/                         # 数据库相关
│   │   ├── __init__.py
│   │   ├── database.py           # 数据库连接
│   │   ├── base.py               # 基础模型
│   │   └── session.py            # 会话管理
│   │
│   └── utils/                      # 工具类
│       ├── __init__.py
│       ├── logger.py             # 日志工具
│       └── id_generator.py       # ID 生成器
│
├── alembic/                        # 数据库迁移
│   ├── versions/
│   └── env.py
│
├── tests/                          # 测试
│   ├── __init__.py
│   ├── test_message.py
│   ├── test_ai_service.py
│   └── locustfile.py             # 压测脚本
│
├── requirements.txt                # Python 依赖
├── .env.example                    # 环境变量示例
├── alembic.ini                     # Alembic 配置
└── README.md                       # 项目说明
```

---

## 二、模块详细设计

### 2.1 配置管理模块 (app/config.py)

#### 功能说明
- 管理应用配置
- 支持环境变量
- 配置验证

#### 设计要点

```python
from pydantic_settings import BaseSettings
from typing import Optional

class Settings(BaseSettings):
    # 应用配置
    app_name: str = "IM Service"
    app_version: str = "1.0.0"
    debug: bool = False
    
    # 数据库配置
    database_url: str
    
    # Redis 配置
    redis_url: str = "redis://localhost:6379/0"
    
    # Celery 配置
    celery_broker_url: str
    celery_result_backend: str
    
    # AI 配置
    ai_provider: str = "openai"  # openai, anthropic, deepseek
    ai_api_key: str
    ai_base_url: Optional[str] = None
    ai_model: str = "gpt-3.5-turbo"
    ai_temperature: float = 0.7
    ai_max_tokens: int = 1000
    
    # WebSocket 配置
    websocket_max_connections: int = 1000
    
    # 日志配置
    log_level: str = "INFO"
    log_format: str = "json"
    
    class Config:
        env_file = ".env"
        case_sensitive = False

settings = Settings()
```

---

### 2.2 数据库模块 (app/db/)

#### 2.2.1 数据库连接 (database.py)

```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from app.config import settings

engine = create_engine(
    settings.database_url,
    pool_pre_ping=True,
    pool_size=10,
    max_overflow=20
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

def get_db():
    """获取数据库会话"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

#### 2.2.2 基础模型 (base.py)

```python
from sqlalchemy import Column, BigInteger, DateTime
from sqlalchemy.sql import func
from app.db.database import Base

class BaseModel(Base):
    __abstract__ = True
    
    id = Column(BigInteger, primary_key=True, index=True)
    created_at = Column(DateTime, server_default=func.now(), nullable=False)
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now(), nullable=False)
```

---

### 2.3 数据模型模块 (app/models/)

#### 2.3.1 消息模型 (message.py)

```python
from sqlalchemy import Column, String, Text, Index
from app.db.base import BaseModel

class Message(BaseModel):
    __tablename__ = "messages"
    
    message_id = Column(String(64), unique=True, nullable=False, index=True)
    session_id = Column(String(48), nullable=False, index=True)
    from_user_id = Column(String(48), nullable=False, index=True)
    msg_type = Column(String(32), nullable=False, default="TEXT")
    msg_content = Column(Text, nullable=False)
    
    __table_args__ = (
        Index('idx_session_created', 'session_id', 'created_at'),
    )
```

#### 2.3.2 AI 聊天记录模型 (ai_chat_record.py)

```python
from sqlalchemy import Column, String, Text, Integer, BigInteger
from app.db.base import BaseModel

class AIChatRecord(BaseModel):
    __tablename__ = "ai_chat_records"
    
    record_id = Column(String(64), unique=True, nullable=False, index=True)
    session_id = Column(String(48), nullable=False, index=True)
    user_message_id = Column(String(64), nullable=False, index=True)
    ai_message_id = Column(String(64), nullable=True)
    request_content = Column(Text, nullable=True)
    response_content = Column(Text, nullable=True)
    status = Column(Integer, nullable=False, default=0)  # 0-处理中，1-成功，2-失败
    duration_ms = Column(BigInteger, nullable=True)
    error_message = Column(String(500), nullable=True)
```

---

### 2.4 Schema 模块 (app/schemas/)

#### 2.4.1 消息 Schema (message.py)

```python
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional

class MessageCreate(BaseModel):
    content: str = Field(..., min_length=1, max_length=5000)
    session_id: str = Field(..., min_length=1, max_length=48)

class MessageResponse(BaseModel):
    id: int
    message_id: str
    session_id: str
    from_user_id: str
    msg_type: str
    msg_content: str
    created_at: datetime
    
    class Config:
        from_attributes = True

class MessageListResponse(BaseModel):
    messages: list[MessageResponse]
    total: int
    page: int
    page_size: int
```

#### 2.4.2 AI Schema (ai.py)

```python
from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class AIChatRecordResponse(BaseModel):
    id: int
    record_id: str
    session_id: str
    user_message_id: str
    ai_message_id: Optional[str]
    status: int
    duration_ms: Optional[int]
    error_message: Optional[str]
    created_at: datetime
    
    class Config:
        from_attributes = True
```

---

### 2.5 Repository 模块 (app/repositories/)

#### 2.5.1 消息仓储 (message_repository.py)

```python
from sqlalchemy.orm import Session
from sqlalchemy import desc
from typing import List, Optional
from app.models.message import Message
from app.schemas.message import MessageCreate
from app.utils.id_generator import generate_message_id

class MessageRepository:
    def __init__(self, db: Session):
        self.db = db
    
    def create(self, message_create: MessageCreate, user_id: str) -> Message:
        """创建消息"""
        message = Message(
            message_id=generate_message_id(),
            session_id=message_create.session_id,
            from_user_id=user_id,
            msg_type="TEXT",
            msg_content=message_create.content
        )
        self.db.add(message)
        self.db.commit()
        self.db.refresh(message)
        return message
    
    def get_by_id(self, message_id: str) -> Optional[Message]:
        """根据消息ID获取消息"""
        return self.db.query(Message).filter(Message.message_id == message_id).first()
    
    def get_by_session(
        self, 
        session_id: str, 
        page: int = 1, 
        page_size: int = 20
    ) -> tuple[List[Message], int]:
        """根据会话ID获取消息列表"""
        query = self.db.query(Message).filter(Message.session_id == session_id)
        total = query.count()
        messages = query.order_by(desc(Message.created_at)).offset(
            (page - 1) * page_size
        ).limit(page_size).all()
        return messages, total
```

#### 2.5.2 AI 聊天记录仓储 (ai_chat_repository.py)

```python
from sqlalchemy.orm import Session
from typing import Optional
from app.models.ai_chat_record import AIChatRecord
from app.utils.id_generator import generate_record_id

class AIChatRecordRepository:
    def __init__(self, db: Session):
        self.db = db
    
    def create(
        self, 
        session_id: str, 
        user_message_id: str,
        request_content: str
    ) -> AIChatRecord:
        """创建 AI 聊天记录"""
        record = AIChatRecord(
            record_id=generate_record_id(),
            session_id=session_id,
            user_message_id=user_message_id,
            request_content=request_content,
            status=0  # 处理中
        )
        self.db.add(record)
        self.db.commit()
        self.db.refresh(record)
        return record
    
    def update_success(
        self,
        record_id: str,
        ai_message_id: str,
        response_content: str,
        duration_ms: int
    ) -> Optional[AIChatRecord]:
        """更新为成功状态"""
        record = self.db.query(AIChatRecord).filter(
            AIChatRecord.record_id == record_id
        ).first()
        if record:
            record.ai_message_id = ai_message_id
            record.response_content = response_content
            record.status = 1  # 成功
            record.duration_ms = duration_ms
            self.db.commit()
            self.db.refresh(record)
        return record
    
    def update_failed(
        self,
        record_id: str,
        error_message: str
    ) -> Optional[AIChatRecord]:
        """更新为失败状态"""
        record = self.db.query(AIChatRecord).filter(
            AIChatRecord.record_id == record_id
        ).first()
        if record:
            record.status = 2  # 失败
            record.error_message = error_message
            self.db.commit()
            self.db.refresh(record)
        return record
```

---

### 2.6 服务层模块 (app/services/)

#### 2.6.1 消息服务 (message_service.py)

```python
from sqlalchemy.orm import Session
from app.repositories.message_repository import MessageRepository
from app.schemas.message import MessageCreate, MessageResponse
from app.tasks.ai_reply_task import trigger_ai_reply

class MessageService:
    def __init__(self, db: Session):
        self.message_repo = MessageRepository(db)
    
    def send_message(
        self, 
        message_create: MessageCreate, 
        user_id: str
    ) -> MessageResponse:
        """发送消息"""
        # 1. 保存消息
        message = self.message_repo.create(message_create, user_id)
        
        # 2. 触发 AI 回复（异步）
        trigger_ai_reply.delay(
            message_id=message.message_id,
            session_id=message.session_id,
            content=message.msg_content
        )
        
        return MessageResponse.from_orm(message)
    
    def get_message(self, message_id: str) -> MessageResponse:
        """获取单条消息"""
        message = self.message_repo.get_by_id(message_id)
        if not message:
            raise ValueError(f"Message not found: {message_id}")
        return MessageResponse.from_orm(message)
    
    def get_messages(
        self, 
        session_id: str, 
        page: int = 1, 
        page_size: int = 20
    ) -> tuple[list[MessageResponse], int]:
        """获取消息列表"""
        messages, total = self.message_repo.get_by_session(
            session_id, page, page_size
        )
        return [MessageResponse.from_orm(m) for m in messages], total
```

#### 2.6.2 AI 服务 (ai_service.py)

```python
from langchain.llms import OpenAI
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from app.config import settings
from typing import Optional

class AIService:
    def __init__(self):
        self.llm = OpenAI(
            temperature=settings.ai_temperature,
            max_tokens=settings.ai_max_tokens,
            openai_api_key=settings.ai_api_key,
            openai_api_base=settings.ai_base_url
        )
        self.prompt = PromptTemplate(
            input_variables=["user_message"],
            template="你是一个AI助手，请友好地回复用户：{user_message}"
        )
        self.chain = LLMChain(llm=self.llm, prompt=self.prompt)
    
    def reply(self, user_message: str) -> str:
        """生成 AI 回复"""
        try:
            response = self.chain.run(user_message)
            return response.strip()
        except Exception as e:
            raise Exception(f"AI service error: {str(e)}")
    
    def reply_stream(self, user_message: str):
        """流式生成 AI 回复"""
        try:
            for chunk in self.chain.stream({"user_message": user_message}):
                yield chunk
        except Exception as e:
            raise Exception(f"AI service error: {str(e)}")
```

#### 2.6.3 WebSocket 服务 (websocket_service.py)

```python
from app.websocket.manager import ConnectionManager
from typing import Optional

class WebSocketService:
    def __init__(self):
        self.manager = ConnectionManager()
    
    async def send_message_to_user(
        self, 
        user_id: str, 
        message: dict
    ) -> bool:
        """发送消息给指定用户"""
        return await self.manager.send_personal_message(
            message, user_id
        )
    
    async def broadcast_message(self, message: dict) -> int:
        """广播消息给所有连接的用户"""
        return await self.manager.broadcast(message)
```

---

### 2.7 WebSocket 模块 (app/websocket/)

#### 2.7.1 连接管理器 (manager.py)

```python
from fastapi import WebSocket
from typing import Dict, List
import json

class ConnectionManager:
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
    
    async def connect(self, websocket: WebSocket, user_id: str):
        """建立 WebSocket 连接"""
        await websocket.accept()
        self.active_connections[user_id] = websocket
    
    def disconnect(self, user_id: str):
        """断开 WebSocket 连接"""
        if user_id in self.active_connections:
            del self.active_connections[user_id]
    
    async def send_personal_message(
        self, 
        message: dict, 
        user_id: str
    ) -> bool:
        """发送消息给指定用户"""
        if user_id in self.active_connections:
            try:
                websocket = self.active_connections[user_id]
                await websocket.send_text(json.dumps(message))
                return True
            except Exception as e:
                # 连接已断开，移除连接
                self.disconnect(user_id)
                return False
        return False
    
    async def broadcast(self, message: dict) -> int:
        """广播消息给所有连接的用户"""
        disconnected = []
        message_text = json.dumps(message)
        
        for user_id, websocket in self.active_connections.items():
            try:
                await websocket.send_text(message_text)
            except Exception:
                disconnected.append(user_id)
        
        # 移除断开的连接
        for user_id in disconnected:
            self.disconnect(user_id)
        
        return len(self.active_connections)
```

#### 2.7.2 消息处理器 (handler.py)

```python
from fastapi import WebSocket, WebSocketDisconnect
from app.websocket.manager import ConnectionManager
from app.services.message_service import MessageService
from app.schemas.message import MessageCreate
from sqlalchemy.orm import Session

class WebSocketHandler:
    def __init__(self, manager: ConnectionManager, db: Session):
        self.manager = manager
        self.message_service = MessageService(db)
    
    async def handle_connection(
        self, 
        websocket: WebSocket, 
        user_id: str
    ):
        """处理 WebSocket 连接"""
        await self.manager.connect(websocket, user_id)
        try:
            while True:
                data = await websocket.receive_text()
                # 解析消息
                message_data = json.loads(data)
                
                # 处理消息
                if message_data.get("type") == "send_message":
                    await self.handle_send_message(
                        user_id, 
                        message_data.get("content")
                    )
        except WebSocketDisconnect:
            self.manager.disconnect(user_id)
    
    async def handle_send_message(
        self, 
        user_id: str, 
        content: str
    ):
        """处理发送消息"""
        message_create = MessageCreate(
            content=content,
            session_id=user_id  # 简化：使用 user_id 作为 session_id
        )
        message = self.message_service.send_message(
            message_create, 
            user_id
        )
        
        # 发送确认消息
        await self.manager.send_personal_message({
            "type": "message_sent",
            "message_id": message.message_id,
            "content": message.msg_content
        }, user_id)
```

---

### 2.8 Celery 任务模块 (app/tasks/)

#### 2.8.1 Celery 应用配置 (celery_app.py)

```python
from celery import Celery
from app.config import settings

celery_app = Celery(
    "im_service",
    broker=settings.celery_broker_url,
    backend=settings.celery_result_backend
)

celery_app.conf.update(
    task_serializer='json',
    accept_content=['json'],
    result_serializer='json',
    timezone='UTC',
    enable_utc=True,
    task_track_started=True,
    task_time_limit=300,  # 5分钟超时
    worker_prefetch_multiplier=1,
    worker_max_tasks_per_child=1000,
)
```

#### 2.8.2 AI 回复任务 (ai_reply_task.py)

```python
from app.tasks.celery_app import celery_app
from app.services.ai_service import AIService
from app.services.websocket_service import WebSocketService
from app.repositories.message_repository import MessageRepository
from app.repositories.ai_chat_repository import AIChatRecordRepository
from app.db.database import SessionLocal
from app.utils.id_generator import generate_message_id
import time
import json

@celery_app.task(name="ai_reply_task")
def trigger_ai_reply(message_id: str, session_id: str, content: str):
    """触发 AI 回复任务"""
    db = SessionLocal()
    try:
        # 1. 创建 AI 聊天记录
        ai_repo = AIChatRecordRepository(db)
        request_content = json.dumps({
            "user_message": content,
            "message_id": message_id
        })
        record = ai_repo.create(session_id, message_id, request_content)
        
        # 2. 调用 AI 服务
        ai_service = AIService()
        start_time = time.time()
        try:
            ai_response = ai_service.reply(content)
            duration_ms = int((time.time() - start_time) * 1000)
            
            # 3. 保存 AI 回复消息
            message_repo = MessageRepository(db)
            ai_message = message_repo.create(
                MessageCreate(
                    content=ai_response,
                    session_id=session_id
                ),
                "ai_bot"  # AI 机器人 ID
            )
            
            # 4. 更新 AI 聊天记录
            ai_repo.update_success(
                record.record_id,
                ai_message.message_id,
                json.dumps({"response": ai_response}),
                duration_ms
            )
            
            # 5. 通过 WebSocket 推送回复
            websocket_service = WebSocketService()
            websocket_service.send_message_to_user(session_id, {
                "type": "ai_reply",
                "message_id": ai_message.message_id,
                "content": ai_response,
                "user_message_id": message_id
            })
            
        except Exception as e:
            # 更新为失败状态
            ai_repo.update_failed(record.record_id, str(e))
            raise
        
    finally:
        db.close()
```

---

### 2.9 API 路由模块 (app/api/)

#### 2.9.1 消息 API (message.py)

```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.db.database import get_db
from app.schemas.message import MessageCreate, MessageResponse, MessageListResponse
from app.services.message_service import MessageService
from typing import Optional

router = APIRouter(prefix="/message", tags=["message"])

@router.post("/send", response_model=MessageResponse)
async def send_message(
    message_create: MessageCreate,
    user_id: str = "default_user",  # 简化：实际应该从认证中获取
    db: Session = Depends(get_db)
):
    """发送消息"""
    message_service = MessageService(db)
    return message_service.send_message(message_create, user_id)

@router.get("/{message_id}", response_model=MessageResponse)
async def get_message(
    message_id: str,
    db: Session = Depends(get_db)
):
    """获取单条消息"""
    message_service = MessageService(db)
    try:
        return message_service.get_message(message_id)
    except ValueError as e:
        raise HTTPException(status_code=404, detail=str(e))

@router.get("/list", response_model=MessageListResponse)
async def get_messages(
    session_id: str,
    page: int = 1,
    page_size: int = 20,
    db: Session = Depends(get_db)
):
    """获取消息列表"""
    message_service = MessageService(db)
    messages, total = message_service.get_messages(
        session_id, page, page_size
    )
    return MessageListResponse(
        messages=messages,
        total=total,
        page=page,
        page_size=page_size
    )
```

---

### 2.10 工具模块 (app/utils/)

#### 2.10.1 ID 生成器 (id_generator.py)

```python
import uuid
from datetime import datetime

def generate_message_id() -> str:
    """生成消息ID"""
    return f"msg_{datetime.now().strftime('%Y%m%d%H%M%S')}_{uuid.uuid4().hex[:8]}"

def generate_record_id() -> str:
    """生成记录ID"""
    return f"record_{datetime.now().strftime('%Y%m%d%H%M%S')}_{uuid.uuid4().hex[:8]}"
```

#### 2.10.2 日志工具 (logger.py)

```python
import logging
import json
from app.config import settings

class JSONFormatter(logging.Formatter):
    def format(self, record):
        log_data = {
            "timestamp": self.formatTime(record),
            "level": record.levelname,
            "message": record.getMessage(),
            "module": record.module,
            "function": record.funcName,
            "line": record.lineno
        }
        if hasattr(record, "extra"):
            log_data.update(record.extra)
        return json.dumps(log_data)

def setup_logger():
    logger = logging.getLogger("im_service")
    logger.setLevel(getattr(logging, settings.log_level))
    
    handler = logging.StreamHandler()
    if settings.log_format == "json":
        handler.setFormatter(JSONFormatter())
    else:
        handler.setFormatter(
            logging.Formatter(
                '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
        )
    
    logger.addHandler(handler)
    return logger

logger = setup_logger()
```

---

### 2.11 主应用入口 (app/main.py)

```python
from fastapi import FastAPI, WebSocket, Depends
from fastapi.middleware.cors import CORSMiddleware
from sqlalchemy.orm import Session
from app.config import settings
from app.api import message, ai
from app.websocket.handler import WebSocketHandler
from app.websocket.manager import ConnectionManager
from app.db.database import get_db
from app.utils.logger import logger

app = FastAPI(
    title="IM Service",
    version=settings.app_version,
    description="轻量级 IM 服务"
)

# CORS 配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 注册路由
app.include_router(message.router)
app.include_router(ai.router)

# WebSocket 管理器
manager = ConnectionManager()

@app.websocket("/ws/{user_id}")
async def websocket_endpoint(
    websocket: WebSocket, 
    user_id: str,
    db: Session = Depends(get_db)
):
    """WebSocket 端点"""
    handler = WebSocketHandler(manager, db)
    await handler.handle_connection(websocket, user_id)

@app.on_event("startup")
async def startup_event():
    logger.info("IM Service starting up...")

@app.on_event("shutdown")
async def shutdown_event():
    logger.info("IM Service shutting down...")

@app.get("/health")
async def health_check():
    """健康检查"""
    return {"status": "ok", "version": settings.app_version}
```

---

**文档版本**：v1.0  
**创建时间**：2025-01-27  
**最后更新**：2025-01-27

